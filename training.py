#This file is part of Tryton.  The COPYRIGHT file at the top level of
#this repository contains the full copyright notices and license terms.
from decimal import Decimal
from itertools import groupby, chain
from functools import partial
from sql import Table
from datetime import datetime, timedelta, date
import operator
from itertools import izip, groupby
from sql import Column, Literal
from sql.aggregate import Sum
from sql.conditionals import Coalesce

from trytond.model import Workflow, ModelView, ModelSQL, fields
from trytond.wizard import Wizard, StateView, StateAction, StateTransition, \
    Button
from trytond.report import Report
from trytond.tools import reduce_ids
from trytond.pyson import If, Eval, PYSONEncoder, Date, Id
from trytond.transaction import Transaction
from trytond.pool import Pool
from trytond import backend

_ZERO = Decimal(0)

STATES = {
    'readonly': (Eval('state') != 'draft'),
}

STATES_CONFIRMED = {
    'readonly': (Eval('state') != 'draft'),
    'required': (Eval('state') == 'confirmed'),
}

GUARANTEE = [
    ('payment', 'Payment'),
    ('voucher', 'Voucher'),
    ('credit_card', 'Credit Card'),
    ('letter', 'Letter'),
    ]

SOURCE = [
    ('', ''),
    ('web', 'Web'),
    ('yellow_pages', 'Yellow Pages'),
    ('recommended', 'Recommended'),
    ('travel_agency', 'Travel Agency'),
    ('advertising', 'Advertising'),
    ('other', 'Other'),
    ]

INVOICE = [
    ('by_party', 'By Party'),
    ('by_main_guest', 'By Main Guest')
    ]

class TrainingSession(ModelView, ModelSQL):
    'Session'
    __name__ = 'training.session'
    
    confirmed_subscriptions = fields.Function(
                                fields.Integer('Confirmed Subscriptions'),
                                '_confirmed_subscriptions_count')
    draft_subscriptions = fields.Function(fields.Integer('Draft Subscriptions'),
                                                         '_draft_subscriptions_count')
    subscription_lines = fields.One2Many('training.subscription.line',
                                                 'session_id',
                                                 'Subscription Lines',
                                                 readonly=True)

class TrainingSubscription(ModelView, ModelSQL):
    'Subscription'
    __name__ = 'training.subscription'
    
    company = fields.Many2One('company.company', 'Company', required=True,
        states={
            'readonly': (Eval('state') != 'draft') | Eval('lines', [0]),
            },
        domain=[
            ('id', If(Eval('context', {}).contains('company'), '=', '!='),
                Eval('context', {}).get('company', -1)),
            ],
        depends=['state'], select=True)
    reference = fields.Char('Reference', required=True, readonly=True, 
                       help='The unique identifier is generated by the system (customizable)')
    description = fields.Char('Description',
        states={
            'readonly': Eval('state') != 'draft',
            },
        depends=['state'])
    state = fields.Selection([
        ('draft', 'Draft'),
        ('quotation', 'Quotation'),
        ('confirmed', 'Confirmed'),
        ('processing', 'Processing'),
        ('done', 'Done'),
        ('cancel', 'Canceled'),
    ], 'State', readonly=True, required=True)
    date = fields.DateTime('Date', readonly=True)
    subscriptor = fields.Many2One('party.party', 'Subscriptor', 
                              required=True)
    invoice_address = fields.Many2One('party.address', 'Invoice Address',
        domain=[('party', '=', Eval('party'))], states={
            'readonly': Eval('state') != 'draft',
            }, depends=['state', 'party'])
    student = fields.Many2One('training.student', 'Student', 
                              required=True)
    currency = fields.Many2One('currency.currency', 'Currency', required=True,
        states={
            'readonly': (Eval('state') != 'draft') |
                (Eval('lines', [0]) & Eval('currency', 0)),
            },
        depends=['state'])
    currency_digits = fields.Function(fields.Integer('Currency Digits',
            on_change_with=['currency']), 'on_change_with_currency_digits')
    subscription_lines = fields.One2Many('training.subscription.line', 'subscription',
                                                  'Subscription Lines')
    price_list = fields.Many2One('product.price_list', 'Price List',
        domain=[('company', '=', Eval('company'))], 
        states=STATES)
    payment_term = fields.Many2One('account.invoice.payment_term',
        'Payment Term', required=True, states={
            'readonly': Eval('state') != 'draft',
            },
        depends=['state'])
    untaxed_amount = fields.Function(fields.Numeric('Untaxed',
            digits=(16, Eval('currency_digits', 2)),
            depends=['currency_digits']), 'get_amount')
    tax_amount = fields.Function(fields.Numeric('Tax',
            digits=(16, Eval('currency_digits', 2)),
            depends=['currency_digits']), 'get_amount')
    total_amount = fields.Function(fields.Numeric('Total',
            digits=(16, Eval('currency_digits', 2)),
            depends=['currency_digits']), 'get_amount')
    invoice_method = fields.Selection(INVOICE, 'Invoice Method',
        required=True, states=STATES)
    invoice_state = fields.Selection([
            ('none', 'None'),
            ('waiting', 'Waiting'),
            ('paid', 'Paid'),
            ('exception', 'Exception'),
            ], 'Invoice State', readonly=True, required=True)
    invoices = fields.Many2Many('sale.sale-account.invoice',
            'sale', 'invoice', 'Invoices', readonly=True)
    invoices_ignored = fields.Many2Many('sale.sale-ignored-account.invoice',
            'sale', 'invoice', 'Ignored Invoices', readonly=True)
    invoices_recreated = fields.Many2Many(
        'sale.sale-recreated-account.invoice', 'sale', 'invoice',
        'Recreated Invoices', readonly=True)
    source_contact = fields.Selection(SOURCE, 'Source Contact', states=STATES,
        help="Advertising source that create subscription by course.")
    sales = fields.Many2Many('subscription_sales_rel', 'subscription', 'sale', 'Sales',
                             readonly=True)
    
    @classmethod
    def __setup__(cls):
        super(TrainingSubscription, cls).__setup__()
        cls._order.insert(0, ('sale_date', 'DESC'))
        cls._order.insert(1, ('id', 'DESC'))
        cls._error_messages.update({
                'missing_account_receivable': ('It misses '
                        'an "Account Receivable" on the party "%s".'),
                'delete_cancel': ('Sale "%s" must be cancelled before '
                    'deletion.'),
                })
        cls._transitions |= set((
                ('draft', 'quotation'),
                ('quotation', 'confirmed'),
                ('confirmed', 'processing'),
                ('processing', 'processing'),
                ('draft', 'cancel'),
                ('quotation', 'cancel'),
                ('quotation', 'draft'),
                ('cancel', 'draft'),
                ))
        cls._buttons.update({
                'cancel': {
                    'invisible': ~Eval('state').in_(['draft', 'quotation']),
                    },
                'draft': {
                    'invisible': ~Eval('state').in_(['cancel', 'quotation']),
                    'icon': If(Eval('state') == 'cancel', 'tryton-clear',
                        'tryton-go-previous'),
                    },
                'quote': {
                    'invisible': Eval('state') != 'draft',
                    'readonly': ~Eval('lines', []),
                    },
                'confirm': {
                    'invisible': Eval('state') != 'quotation',
                    },
                'process': {
                    'invisible': Eval('state') != 'confirmed',
                    },
                'handle_invoice_exception': {
                    'invisible': ((Eval('invoice_state') != 'exception')
                        | (Eval('state') == 'cancel')),
                    'readonly': ~Eval('groups', []).contains(
                        Id('sale', 'group_sale')),
                    },
                'handle_shipment_exception': {
                    'invisible': ((Eval('shipment_state') != 'exception')
                        | (Eval('state') == 'cancel')),
                    'readonly': ~Eval('groups', []).contains(
                        Id('sale', 'group_sale')),
                    },
                })
        # The states where amounts are cached
        cls._states_cached = ['confirmed', 'processing', 'done', 'cancel']
    
    @classmethod
    def __register__(cls, module_name):
        super(TrainingSubscription, cls).__register__(module_name)
    
    def get_rec_name(self, name):
        return self.reference
    
    @staticmethod
    def default_currency():
        Company = Pool().get('company.company')
        company = Transaction().context.get('company')
        if company:
            return Company(company).currency.id

    @staticmethod
    def default_company():
        return Transaction().context.get('company')

    @staticmethod
    def default_state():
        return 'draft'

    @staticmethod
    def default_invoice_method():
        return 'by_party'
    
    def on_change_party(self):
        res = {}
        res['price_list'] = None
        if self.party and self.party.sale_price_list:
            res['price_list'] = self.party.sale_price_list.id
            res['price_list.rec_name'] = self.party.sale_price_list.rec_name
        return res

    def on_change_lines(self):
        pool = Pool()
        Tax = pool.get('account.tax')
        Invoice = pool.get('account.invoice')

        res = {
            'untaxed_amount': Decimal('0.0'),
            'tax_amount': Decimal('0.0'),
            'total_amount': Decimal('0.0'),
            }

        if self.lines:
            taxes = {}
            for line in self.lines:
                if getattr(line, 'type', 'line') != 'line':
                    continue
                res['untaxed_amount'] += line.amount or Decimal(0)
                tax_list = ()
                with Transaction().set_context(self.get_tax_context()):
                    tax_list = Tax.compute(getattr(line, 'taxes', []),
                        line.unit_price or Decimal('0.0'),
                        line.quantity or 0.0)
                for tax in tax_list:
                    key, val = Invoice._compute_tax(tax, 'out_invoice')
                    if not key in taxes:
                        taxes[key] = val['amount']
                    else:
                        taxes[key] += val['amount']
            if self.currency:
                for key in taxes:
                    res['tax_amount'] += self.currency.round(taxes[key])
        if self.currency:
            res['untaxed_amount'] = self.currency.round(res['untaxed_amount'])
            res['tax_amount'] = self.currency.round(res['tax_amount'])
        res['total_amount'] = res['untaxed_amount'] + res['tax_amount']
        if self.currency:
            res['total_amount'] = self.currency.round(res['total_amount'])
        return res

    def get_tax_amount(self):
        pool = Pool()
        Tax = pool.get('account.tax')
        Invoice = pool.get('account.invoice')

        context = self.get_tax_context()
        taxes = {}
        for line in self.lines:
            if line.type != 'line':
                continue
            with Transaction().set_context(context):
                tax_list = Tax.compute(line.taxes, line.unit_price,
                    line.quantity)
            # Don't round on each line to handle rounding error
            for tax in tax_list:
                key, val = Invoice._compute_tax(tax, 'out_invoice')
                if not key in taxes:
                    taxes[key] = val['amount']
                else:
                    taxes[key] += val['amount']
        return sum((self.currency.round(tax) for tax in taxes.values()), _ZERO)

    @classmethod
    def get_amount(cls, subscriptions, names):
        untaxed_amount = {}
        tax_amount = {}
        total_amount = {}

        for subscription in subscriptions:
            if (sale.state in cls._states_cached
                    and sale.untaxed_amount_cache is not None
                    and sale.tax_amount_cache is not None
                    and sale.total_amount_cache is not None):
                untaxed_amount[sale.id] = sale.untaxed_amount_cache
                tax_amount[sale.id] = sale.tax_amount_cache
                total_amount[sale.id] = sale.total_amount_cache
            else:
                untaxed_amount[sale.id] = sum(
                    (line.amount for line in sale.lines
                        if line.type == 'line'), _ZERO)
                tax_amount[sale.id] = sale.get_tax_amount()
                total_amount[sale.id] = (
                    untaxed_amount[sale.id] + tax_amount[sale.id])

        result = {
            'untaxed_amount': untaxed_amount,
            'tax_amount': tax_amount,
            'total_amount': total_amount,
            }
        for key in result.keys():
            if key not in names:
                del result[key]
        return result

    @classmethod
    def validate(cls, subscriptions):
        super(TrainingSubscription, cls).validate(subscriptions)
        for subscription in subscriptions:
            subscription.check_method()

    def get_rec_name(self, name):
        return (self.reference or str(self.id)
            + ' - ' + self.party.rec_name)

    @classmethod
    def set_reference(cls, subscriptions):
        '''
        Fill the reference field with the sale sequence
        '''
        pool = Pool()
        Sequence = pool.get('ir.sequence')
        Config = pool.get('sale.configuration')

        config = Config(1)
        for subscription in subscriptions:
            if subscription.reference:
                continue
            reference = Sequence.get_id(config.subscription_sequence.id)
            cls.write([subscription], {
                    'reference': reference,
                    })

    @classmethod
    def set_sale_date(cls, subscriptions):
        Date = Pool().get('ir.date')
        for subscription in subscriptions:
            if not subscription.date:
                cls.write([subscription], {
                        'date': Date.today(),
                        })

    @classmethod
    def store_cache(cls, subscriptions):
        for subscription in subscriptions:
            cls.write([subscription], {
                    'untaxed_amount_cache': subscription.untaxed_amount,
                    'tax_amount_cache': subscription.tax_amount,
                    'total_amount_cache': subscription.total_amount,
                    })

    def create_invoice(self, invoice_type):
        '''
        Create and return an invoice of type invoice_type
        '''
        pool = Pool()
        Invoice = pool.get('account.invoice')
        if self.invoice_method == 'manual':
            return

        if not self.party.account_receivable:
            self.raise_user_error('missing_account_receivable',
                (self.party.rec_name,))

        invoice_lines = self._get_invoice_line_sale_line(invoice_type)
        if not invoice_lines:
            return

        invoice = self._get_invoice_sale(invoice_type)
        invoice.lines = ((list(invoice.lines)
                if hasattr(invoice, 'lines') else [])
            + list(chain.from_iterable(invoice_lines.itervalues())))
        invoice.save()

        with Transaction().set_user(0, set_context=True):
            Invoice.update_taxes([invoice])

        self.write([self], {
                'invoices': [('add', [invoice.id])],
                })
        return invoice


        return shipments

    def is_done(self):
        return ((self.invoice_state == 'paid'
                or self.invoice_method == 'manual')
            and (self.shipment_state == 'sent'
                or self.shipment_method == 'manual'))
    
    @classmethod
    def delete(cls, subscriptions):
        # Cancel before delete
        cls.cancel(subscriptions)
        for subscription in subscriptions:
            if subscription.state != 'cancel':
                cls.raise_user_error('delete_cancel', (subscription.rec_name,))
        super(TrainingSubscription, cls).delete(subscriptions)

    @classmethod
    @ModelView.button
    @Workflow.transition('cancel')
    def cancel(cls, subscriptions):
        cls.store_cache(subscriptions)

    @classmethod
    @ModelView.button
    @Workflow.transition('draft')
    def draft(cls, subscriptions):
        pass

    @classmethod
    @ModelView.button
    @Workflow.transition('quotation')
    def quote(cls, subscriptions):
        for subscription in subscriptions:
            subscription.check_for_quotation()
        cls.set_reference(subscription)

    @classmethod
    @ModelView.button
    @Workflow.transition('confirmed')
    def confirm(cls, subscriptions):
        cls.set_sale_date(subscriptions)
        cls.store_cache(subscriptions)
        cls.create_sale_lines_boms(subscriptions)

    @classmethod
    @ModelView.button_action('subscription.wizard_invoice_handle_exception')
    def handle_invoice_exception(cls, subscriptions):
        pass

    @classmethod
    @ModelView.button_action('subscription.wizard_shipment_handle_exception')
    def handle_shipment_exception(cls, subscriptions):
        pass

    @classmethod
    @ModelView.button
    @Workflow.transition('processing')
    def process(cls, subscriptions):
        done = []
        for subscription in subscriptions:
            if subscription.state in ('done', 'cancel'):
                continue
            subscription.create_invoice('out_invoice')
            subscription.create_invoice('out_credit_note')
            subscription.set_invoice_state()
            subscription.create_shipment('out')
            subscription.create_shipment('return')
            subscription.set_shipment_state()
            if subscription.is_done():
                done.append(subscription)
        if done:
            cls.write(done, {
                    'state': 'done',
                    })

class SubscriptionInvoice(ModelSQL):
    'Training Subscription - Invoice'
    __name__ = 'training.subscription-account.invoice'
    _table = 'subscription_invoices_rel'
    subscription = fields.Many2One('training.subscription', 'Subscription', ondelete='CASCADE',
        select=True, required=True)
    invoice = fields.Many2One('account.invoice', 'Invoice',
            ondelete='RESTRICT', select=True, required=True)

class SubscriptionIgnoredInvoice(ModelSQL):
    'Subscription - Ignored Invoice'
    __name__ = 'training.subscription-ignored-account.invoice'
    _table = 'subscription_invoice_ignored_rel'
    subscription = fields.Many2One('training.subscription', 'Training', ondelete='CASCADE',
        select=True, required=True)
    invoice = fields.Many2One('account.invoice', 'Invoice',
            ondelete='RESTRICT', select=True, required=True)


class SubscriptionRecreatedInvoice(ModelSQL):
    'Sale - Recreated Invoice'
    __name__ = 'training.subscription-recreated-account.invoice'
    _table = 'subscription_invoice_recreated_rel'
    subscription = fields.Many2One('training.subscription', 'Subscription', ondelete='CASCADE',
        select=True, required=True)
    invoice = fields.Many2One('account.invoice', 'Invoice',
            ondelete='RESTRICT', select=True, required=True)

class TrainingSubscriptionLine(ModelView, ModelSQL):
    'Subscription Line'
    __name__ = 'training.subscription.line'

    subscription =fields.Many2One('training.subscription', 'Subscription',
                                            required=True,
                                            ondelete='CASCADE',
                                            help='Select the subscription')
    session = fields.Many2One('training.session', 'Session', required=True,
                                       domain=[('state', 'in', ('opened', 
                                                            'opened_confirmed', 
                                                            'closed_confirmed', 
                                                            'inprogress'))],
                                       help='Select the session')
    invoices = fields.Many2Many('subscription_invoices_rel','subscription', 'invoice', 'Invoices', 
                                readonly=True)
    internal_note = fields.Text("Internal Note")
    email_note = fields.Text("Email Note")

    @staticmethod
    def default_state(self):
        return 'draft'
    