#This file is part of Tryton.  The COPYRIGHT file at the top level of
#this repository contains the full copyright notices and license terms.
from decimal import Decimal
from itertools import groupby, chain
from functools import partial
from sql import Table
from datetime import datetime, timedelta, date
import operator
from itertools import izip, groupby
from sql import Column, Literal
from sql.aggregate import Sum
from sql.conditionals import Coalesce

from trytond.model import Workflow, ModelView, ModelSQL, fields
from trytond.wizard import Wizard, StateView, StateAction, StateTransition, \
    Button
from trytond.report import Report
from trytond.tools import reduce_ids
from trytond.pyson import If, Eval, PYSONEncoder, Date, Id
from trytond.transaction import Transaction
from trytond.pool import Pool
from trytond import backend

_ZERO = Decimal(0)

STATES = {
    'readonly': (Eval('state') != 'draft'),
}

STATES_CONFIRMED = {
    'readonly': (Eval('state') != 'draft'),
    'required': (Eval('state') == 'confirmed'),
}

GUARANTEE = [
    ('payment', 'Payment'),
    ('voucher', 'Voucher'),
    ('credit_card', 'Credit Card'),
    ('letter', 'Letter'),
    ]

MEDIA = [
    ('', ''),
    ('web', 'Web'),
    ('yellow_pages', 'Yellow Pages'),
    ('recommended', 'Recommended'),
    ('travel_agency', 'Travel Agency'),
    ('advertising', 'Advertising'),
    ('other', 'Other'),
    ]

INVOICE = [
    ('by_subscriptor', 'By Subscriptor'),
    ('by_student', 'By Student')
    ]

class TrainingSubscription(ModelView, ModelSQL):
    'Subscription'
    __name__ = 'training.subscription'
    
    company = fields.Many2One('company.company', 'Company', required=True,
        states={
            'readonly': (Eval('state') != 'draft') | Eval('lines', [0]),
            },
        domain=[
            ('id', If(Eval('context', {}).contains('company'), '=', '!='),
                Eval('context', {}).get('company', -1)),
            ],
        depends=['state'], select=True)
    reference = fields.Char('Reference', required=True, readonly=True, 
            help='The unique identifier is generated by the system (customizable)',
            states={
            'readonly': (Eval('state') != 'draft') | Eval('lines', [0]),
            },)
    description = fields.Char('Description',
        states={
            'readonly': Eval('state') != 'draft',
            },
        depends=['state'])
    state = fields.Selection([
        ('draft', 'Draft'),
        ('quotation', 'Quotation'),
        ('confirmed', 'Confirmed'),
        ('processing', 'Processing'),
        ('done', 'Done'),
        ('cancel', 'Canceled'),
    ], 'State', readonly=True, required=True)
    date = fields.DateTime('Date', readonly=True)
    subscriptor = fields.Many2One('party.party', 'Subscriptor', 
                              required=True)
    student = fields.Many2One('training.student', 'Student', 
                              required=True)
    currency = fields.Many2One('currency.currency', 'Currency', required=True,
        states={
            'readonly': (Eval('state') != 'draft') |
                (Eval('lines', [0]) & Eval('currency', 0)),
            },
        depends=['state'])
    lines = fields.One2Many('training.subscription.line', 'subscription',
                                                  'Subscription Lines')
    price_list = fields.Many2One('product.price_list', 'Price List',
        domain=[('company', '=', Eval('company'))], 
        states=STATES)
    payment_term = fields.Many2One('account.invoice.payment_term',
        'Payment Term', required=True, states={
            'readonly': Eval('state') != 'draft',
            },
        depends=['state'])
    media_contact = fields.Selection(MEDIA, 'Media Contact', states=STATES,
        help="Advertising media that create subscription by course.")
    untaxed_amount = fields.Function(fields.Numeric('Untaxed',
            digits=(16, Eval('currency_digits', 2)),
            depends=['currency_digits']), 'get_amount')
    tax_amount = fields.Function(fields.Numeric('Tax',
            digits=(16, Eval('currency_digits', 2)),
            depends=['currency_digits']), 'get_amount')
    total_amount = fields.Function(fields.Numeric('Total',
            digits=(16, Eval('currency_digits', 2)),
            depends=['currency_digits']), 'get_amount')
    invoices = fields.Many2Many('sale.sale-account.invoice',
            'sale', 'invoice', 'Invoices', readonly=True)
    sales = fields.Many2Many('subscription_sales_rel', 'subscription', 'sale', 'Sales',
                             readonly=True)
    invoice_method = fields.Selection(INVOICE, 'Invoice Method',
        required=True, states=STATES)
        
    @classmethod
    def __setup__(cls):
        super(Booking, cls).__setup__()
        cls._order.insert(0, ('create_date', 'DESC'))
        cls._transitions |= set((
                ('draft', 'confirmed'),
                ('draft', 'canceled'),
                ('confirmed', 'no_submited'),
                ('confirmed', 'guaranteed'),
                ('guaranteed', 'canceled'),
                ('confirmed', 'submited'),
                ('confirmed', 'canceled'),
                ))
        cls._buttons.update({
                'cancel': {
                    'invisible': ~Eval('state').in_(['draft', 'confirmed']),
                    },
                'draft': {
                    'invisible': Eval('state') != 'confirmed',
                    },
                'confirm': {
                    'invisible': Eval('state') != 'draft',
                    },
                'submit': {
                    'invisible': Eval('state') != 'confirmed',
                    },
                'guaranteed': {
                    'invisible': Eval('state') != 'confirmed',
                    },
                'no_submit': {
                    'invisible': Eval('state') != 'confirmed',
                    },
                })
        cls._error_messages.update({
                'payterm_missing': ('The payment term is missing!'),
                })
        
    @classmethod
    @ModelView.button
    @Workflow.transition('draft')
    def draft(cls, records):
        pass

    @classmethod
    @ModelView.button
    @Workflow.transition('cancel')
    def cancel(cls, records):
        pass
        #stop subscriptions 

    @classmethod
    @ModelView.button
    @Workflow.transition('confirmed')
    def confirm(cls, records):
        cls.set_reference(records)
        for record in records:
            cls._create_presale(record)
            record.update_operation_state('confirmed')
    
    @classmethod
    @ModelView.button
    @Workflow.transition('no_submited')
    def no_submit(cls, records):
        for record in records:
            for line in record.lines:
                Operation.delete([line.operation])

    @classmethod
    @ModelView.button
    @Workflow.transition('submited')
    def submit(cls, records):
        for record in records:
            record.update_operation_state('submited')
    
    @classmethod
    def set_reference(cls, subscriptions):
        '''
        Fill the reference field with the sale sequence
        '''
        pool = Pool()
        Sequence = pool.get('ir.sequence')
        Config = Pool().get('training.sequences')

        config = Config(1)
        for subscription in subscriptions:
            if subscription.reference:
                continue
            reference = Sequence.get_id(config.subscription_sequence.id)
            cls.write([subscription], {
                    'reference': reference,
                    })
    
    @classmethod
    def _create_presale(cls, subscription):
        pool = Pool()
        Party = pool.get('party.party')
        SaleLine = pool.get('sale.line')
        Sale = pool.get('sale.sale')
        Configuration = pool.get('training.configuration')
        configuration = Configuration(1)
        Model = pool.get('ir.model')
        date_ = datetime.today().date()
        model = Model.search([('name', '=', str(cls.__name__))])

        if not subscription.payment_term:
            cls.raise_user_error('payterm_missing')

        if not subscription.price_list:
            price_list = None
        else:
            price_list = subscription.price_list.id
            
        if not model:
            model = 'Subscription'
        else:
            model = model[0].name
        description = model + ' No.' + str(booking.reference)

        if subscription.invoice_method == 'by_subscriptor':
            subscriptions_ = [(subscription.subscriptor, subscription.lines),]
        elif booking.invoice_method == 'by_student':
            subscriptions_ = [(subscription.student.name, subscription.lines), ]
        else:
            subscription_ = []

        for party, lines in subscriptions_:
            sale, = Sale.create([{
                'company': subscription.company.id,
                'payment_term': subscription.payment_term.id,
                'party': party.id,
                'price_list' : price_list,
                'sale_date': date_,
                'state': 'draft',
                'invoice_address': Party.address_get(party, type='invoice'),
                'shipment_address': Party.address_get(party, type='delivery'),
                'description': description,
                }])

            for res_line in lines:
                if res_line.quantity <= 0:
                    continue
                new_line = cls._create_new_line(
                        sale, res_line.quantity, res_line.session.name,
                        res_line.unit_price
                        )
                if new_line:
                    SaleLine.create([new_line])

                #Add-Create defult charges lines if exists
                #for product in configuration.default_charges:
                #    new_line = cls._create_new_line(
                #            sale, res_line.quantity, product,
                #            )
                #    if new_line:
                #        SaleLine.create([new_line])
        cls.write([subscription], {'sales': [('add', [sale.id])]})

    @classmethod
    def _create_new_line(cls, sale, quantity, template, unit_price):
        pool = Pool()
        SaleLine = pool.get('sale.line')
        tax_id = []
        product = template.products[0]

        for tax in product.customer_taxes_used:
            tax_id = tax.id

        line = SaleLine()
        line.unit = template.sale_uom
        line.sale = sale.id

        new_line = {
                'sale': sale.id,
                'type': 'line',
                'unit': template.default_uom.id,
                'quantity': quantity,
                'unit_price': unit_price,
                'product': product.id,
                'description': (product.rec_name),
                 }
        if tax_id:
            tax_dict = {'taxes': [('set', [tax_id])]}
            new_line.update(tax_dict)
        return new_line

class SubscriptionSale(ModelSQL):
    'Training Subscription - Sale'
    __name__ = 'training.subscription-sale.sale'
    _table = 'subscription_sales_rel'
    subscription = fields.Many2One('training.subscription', 'Subscription', ondelete='CASCADE',
        select=True, required=True)
    sale = fields.Many2One('sale.sale', 'Sale',
            ondelete='RESTRICT', select=True, required=True)

class SubscriptionInvoice(ModelSQL):
    'Training Subscription - Invoice'
    __name__ = 'training.subscription-account.invoice'
    _table = 'subscription_invoices_rel'
    subscription = fields.Many2One('training.subscription', 'Subscription', ondelete='CASCADE',
        select=True, required=True)
    invoice = fields.Many2One('account.invoice', 'Invoice',
            ondelete='RESTRICT', select=True, required=True)

class TrainingSubscriptionLine(ModelView, ModelSQL):
    'Subscription Line'
    __name__ = 'training.subscription.line'

    subscription =fields.Many2One('training.subscription', 'Subscription',
                                            required=True,
                                            ondelete='CASCADE',
                                            help='Select the subscription')
    session = fields.Many2One('training.session', 'Session', required=True,
                                       domain=[('state', 'in', ['confirmed']),],
                                       help='Select the session')
    unit_price = fields.Numeric('Unit Price', digits=(16, 2))
    quantity = fields.Numeric('Unit Price', digits=(16, 2))
    total_amount = fields.Function(fields.Numeric('Total Amount', 
            digits=(16, 2)), 'get_total_amount')
    notes = fields.Text('Notes')

    @staticmethod
    def default_state(self):
        return 'draft'
    
#class TrainingSession(ModelView, ModelSQL):
#    'Session'
#    __name__ = 'training.session'
    
#    confirmed_subscriptions = fields.Function(
#                                fields.Integer('Confirmed Subscriptions'),
#                                'confirmed_subscriptions_count')
#    draft_subscriptions = fields.Function(fields.Integer('Draft Subscriptions'),
#                                                         '_draft_subscriptions_count')
#    subscription_lines = fields.One2Many('training.subscription.line',
#                                                 'session_id',
#                                                 'Subscription Lines',
#                                                 readonly=True)
